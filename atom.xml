<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aeolos</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aeolos1994.github.io/"/>
  <updated>2018-06-22T04:25:17.806Z</updated>
  <id>https://aeolos1994.github.io/</id>
  
  <author>
    <name>Aeolos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三大框架核心功能源码实现对比（一） 双向绑定</title>
    <link href="https://aeolos1994.github.io/2018/06/21/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>https://aeolos1994.github.io/2018/06/21/源码实现对比（一） 双向绑定/</id>
    <published>2018-06-21T17:41:20.000Z</published>
    <updated>2018-06-22T04:25:17.806Z</updated>
    
    <content type="html"><![CDATA[<p>Vue&amp;Angular(1.x)&amp;React是当今最流行的前端框架，他们对于一些核心功能的实现也是非常优雅、有借鉴意义的，所以我将会总结三大框架的核心功能实现区别，进而见贤思齐。我们第一个要对比的就是现代前端框架绕不开的一个功能 - 双向绑定。这个系列假定阅读的人对于框架原理有一定的了解，所以不会从源头讲起；感觉给自己挖了个大坑，React我也没用过，啧啧…<br><a id="more"></a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先给双向绑定下个定义，准确的知道双向绑定是什么，我们才好去追踪源码的实现。</p><blockquote><p>单向绑定非常简单，就是把Model绑定到View，当我们JavaScript代码更新Model时，View就会自动更新。有单向绑定，就有双向绑定。如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。最常见的View更新操作就是表单输入。<br>既然知道了什么是双向绑定，我们就来找一下三大框架的双向绑定实现的核心源码。</p></blockquote><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>首先我们来看一下最近火热的Vue实现，可能大家一说到Vue的双向绑定都会说到defineProperty，设置getter、setter，巴拉巴拉的，但是再往深了其实就不太了解了，这部分就深度解析Vue的双向绑定实现源码与原理。<br>首先我们先思考一个问题，当我们在Vue实例内部的方法中使用this时，this指向的是当前Vue实例，那有没有想过，为什么我们定义在Vue实例中data中属性，却可以直接通过this.xxx获取到呢，比如下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">test: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">add () &#123;</span><br><span class="line"><span class="keyword">this</span>.test ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>就像上面这样，为什么我们在实例上获取属性时，却可以获取到data上的值呢？其实，vue在这里做了一个代理处理(省略了无关代码)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 定义了一个代理方法  函数位于src/core/instance/state.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="comment">// 这是一个判断是否是保留字的方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      <span class="comment">// 就是在这里调用了代理方法，</span></span><br><span class="line">      <span class="comment">// 将data内的属性挂了一个代理在vue实例上</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据以上代码我们能够大概看出，为什么我们在vue实例上可以获取到各个属性上定义的属性、方法：<strong>就是通过defineProperty将实例上props、data、methods等参数的属性的getter、setter代理到了实例上</strong>。搞清楚这个我们接着看双向绑定的问题，其实在上面的initData代码之后还有一句话，就是双向绑定的入口了,下面的代码就以data为例把vue双向绑定的核心代码提出来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  <span class="comment">// 代码位于core/instance/observer/index.js中</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">  <span class="comment">// 这里实例化了一个观察者对象</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue&amp;amp;Angular(1.x)&amp;amp;React是当今最流行的前端框架，他们对于一些核心功能的实现也是非常优雅、有借鉴意义的，所以我将会总结三大框架的核心功能实现区别，进而见贤思齐。我们第一个要对比的就是现代前端框架绕不开的一个功能 - 双向绑定。这个系列假定阅读的人对于框架原理有一定的了解，所以不会从源头讲起；感觉给自己挖了个大坑，React我也没用过，啧啧…&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://aeolos1994.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>状态压缩 - 解决复杂的判断嵌套</title>
    <link href="https://aeolos1994.github.io/2018/06/16/IFELSE%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    <id>https://aeolos1994.github.io/2018/06/16/IFELSE状态压缩/</id>
    <published>2018-06-16T17:43:48.000Z</published>
    <updated>2018-06-16T11:01:26.304Z</updated>
    
    <content type="html"><![CDATA[<p>之前在工作中碰到了这么一个需求,转化一下需求的话就像是经典的递归地狱一样有非常深层次的if-else嵌套，让我一时感觉非常棘手,整体结构如果不优化的话，会变得如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (boolean1) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> (boolean2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (boolean3) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">      <span class="keyword">if</span> (boolean4) &#123;</span><br><span class="line">        <span class="keyword">if</span> (boolean5) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (boolean6) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">if</span> (boolean7) &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (boolean8) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际需求甚至嵌套比这还要深，不做优化处理的话，代码的可读性与可维护性都会令后面的维护者崩溃，甚至有可能过一段时间连自己都看不懂在写什么。<br>所以我就在考虑如何将这种if-else嵌套打平，让其变得更容易理解与维护。首先我们来抽象这个需求，其实抽象一下的话就是我们在不同的复合条件下需要做不同的操作。关键问题就在于这个复合条件是一层层判断的，如何打平复合条件就成为了我们解决这个优化方案的key point。复合条件的每层判断都是基于父层的判断的，假如我们基于if-else判断的0 1特性，枚举所有的可能的状态，将每个判断条件都转成2进制的0||1，然后压缩为一个二进制的字符串，然后转成数字就可以构成一个 数字范围 - 操作的映射体系。其实这就是状态压缩的思想。  </p><blockquote><p>状态压缩动态规划<br>    动态规划的状态有时候比较难，不容易表示出来，需要用一些编码技术，把状态压缩的用简单的方式表示出来。典型方式：当需要表示一个集合有哪些元素时，往往利用2进制用一个整数表示。  </p></blockquote><p>举个例子：针对上面那段代码我们如何进行压缩优化呢<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> statusMapper = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">statusMapper = &#123;</span><br><span class="line">[n1, n2]: doSth,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> operation = &#123;</span><br><span class="line">noop () &#123;&#125;,</span><br><span class="line">doSth1 () &#123;&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionStatus</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> status = []</span><br><span class="line"><span class="comment">// 依次进行状态判断并转为数字0、1push进数组中</span></span><br><span class="line"><span class="comment">// 整个状态的判断顺序必须是有序的，这会对后续的map操作有影响</span></span><br><span class="line">status.push(<span class="built_in">Number</span>(boolean)) ...</span><br><span class="line"><span class="comment">// 转为10进制</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(status.join(<span class="string">''</span>), <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在已经写好的mapper中查找对应操作</span></span><br><span class="line"><span class="keyword">let</span> decimal = collectionStatus()</span><br><span class="line"><span class="keyword">let</span> doSth = noop</span><br><span class="line">statusMapper.forEach(<span class="function">(<span class="params">operation, range</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(range[<span class="number">0</span>] &gt; state &amp;&amp; state &lt; range[<span class="number">1</span>])&#123;</span><br><span class="line">doSth = operation</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation[doSth]()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在工作中碰到了这么一个需求,转化一下需求的话就像是经典的递归地狱一样有非常深层次的if-else嵌套，让我一时感觉非常棘手,整体结构如果不优化的话，会变得如下所示：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://aeolos1994.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJs跨组件通信方案</title>
    <link href="https://aeolos1994.github.io/2018/06/14/AngularJs%E8%B7%A8%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/"/>
    <id>https://aeolos1994.github.io/2018/06/14/AngularJs跨组件通信方案/</id>
    <published>2018-06-14T17:43:48.000Z</published>
    <updated>2018-06-15T12:21:25.428Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作中需要维护一个AngularJs工程，维护过程中许多场景都需要在page、directive之间以及他们自身之间进行通信，如果现在需要在非父子组件之间通信，你会怎么做呢？使用angular自带的broadcast与emit吗？但是他们的实现机制类似原型链查找，需要一层一层的向上或向下遍历，性能不佳，今天我来分享一个我的解决方案。<br><a id="more"></a></p><h1 id="跨组件通信需要的是什么"><a href="#跨组件通信需要的是什么" class="headerlink" title="跨组件通信需要的是什么"></a>跨组件通信需要的是什么</h1><p>我们提出一个解决方案的前提是有一个需求，明确需求是最基础的要求，也是最重要的点，我们所有的思维都将围绕这一个或几个点来展开。<br>那么我们需要一个怎样的通信方式呢? 我当时主要的需求其实就一个：实现<code>任意点到任意点</code>的<strong>直接</strong>通信，而不是通过层层遍历的方式，这种效率低下的方式我很不爽。但是这里的点对点指的是<code>消息发布源</code>通知<code>消息订阅者</code>的方式是直接通知的，而不是对于scope进行遍历。<br>当然还有其他的要求比如<strong>易用</strong>、<strong>可靠</strong>等等。</p><h1 id="如何实现点到点"><a href="#如何实现点到点" class="headerlink" title="如何实现点到点"></a>如何实现点到点</h1><p>实现点到点的通信，其实灵感来自于vue的<code>Bus</code>,vue的事件总线的效果就是点到点且API简单，内部实现高效的。而我设计自己的通信方案也借鉴了vue的<code>单例</code>+<code>发布订阅</code>模式。首先解决发布订阅的设计，假定现在有两个非父子组件分别为A、B，B需要订阅A发布的某个消息，那么思路肯定为B为某个消息注册一个回调，A通过对应消息触发这个回调，所以我们现在需要的是一个东西来为B存储回调，并可以为A提供接口来触发回调。这个东西就是<code>事件池</code>。<br>让我们来耐心看一小段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.eventPool = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $on (eventName, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.eventPool[eventName].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  $emit (eventName) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.eventPool[eventName])&#123;</span><br><span class="line">  <span class="keyword">this</span>.eventPool[eventName].forEach(<span class="function">(<span class="params">callbacl</span>) =&gt;</span> &#123;</span><br><span class="line">  callbacl()</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上简略代码所示这就是最简单的事件池，他有一个属性，两个方法，属性为一个对象，主要作用为记录订阅者提供的回调函数，而两个方法分别供给发布者与订阅进行订阅与发布事件。这就是一个最简单的基于发布订阅的事件池。这个事件池可以实现点对点的通信，即在A中发布事件，只要B注册了对改事件的监听，基于事件池的HASH结构，就可以直接通知到B而不需要任何的遍历或查找。</p><h1 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h1><p>首先基于上面的时间池我们可以看到，事件池记录了所有的已注册的时间回调，并在消息发布时在事件池拿到响应的回调并执行。单例模式就是在保证事件池的唯一性，假如有多个事件池，那么我们无法拿到所有的事件池实例，也就无从执行对应的回调了。所以单例模式是必须的。</p><h1 id="如何实现单例"><a href="#如何实现单例" class="headerlink" title="如何实现单例"></a>如何实现单例</h1><p>实现单例有多种方式</p><ol><li>可以在实例化后将某一变量指向实例，并在类所在的局部范围记录，构造函数执行时，就去检查该变量。如果变量存在则不执行构造函数，直接return已实例化过的事件池实例。</li><li>可以不定义类，直接定义字面量对象，提供方法返回该字面量对象。<br>而我的实现方式由于是基于angularjs的，我们知道angularjs中的service本身就是单例实现的，所以我利用了这个特性并使用了第二种方法，就是将事件池写在service内，随处引用且保证为同一个事件池。  </li></ol><h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><p>如果一个公共的组件或者服务只追求单纯的实现功能而不考虑其他，那和咸鱼有什么区别。反而越是公共的服务越要追求<code>稳定</code>、<code>易用</code>，因为你写的东西使用范围和场景是很广的，写出来也不光是给自己用的。那么我处理了什么来使其变的<code>稳定易用</code>呢。举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$on (eventName, callback) &#123;</span><br><span class="line">  <span class="keyword">this</span>.eventPool[eventName].push(callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码就存在问题，如果this.eventPool[eventName]没有初始化过，就会导致报错，所以安全的写法是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$on (eventName, callback) &#123;</span><br><span class="line"><span class="keyword">this</span>.eventPool[eventName] = <span class="keyword">this</span>.eventPool[eventName] || []</span><br><span class="line">  <span class="keyword">this</span>.eventPool[eventName].push(callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有在订阅事件时，由于存储的是一个方法的引用，所以可以在注册进入事件池之前进行重复性判断，避免某个组件内对一个事件多次监听的发生。<br>那么易用体现在哪呢，易用其实体现在对外的API友好、简单。我在提供外部API时就使用了非常类似vue中bus提供的API。<br>除了这些还有什么呢，我们在考虑优化时还要考虑他的场景，在工程很大情况下，很多工程师在开发，都在使用bus，那么就很有可能会出现，两个人使用了相同的事件名的情况，由于bus是全局的一个事件总线，所以会互相影响，为了解决这种情况，我引入了<code>私有事件池</code>，也就是说，你可以创建一个自己私有的事件池，所有的订阅与发布都在私有事件池内进行的，既不会影响其他人，也最大程度的减少受到别人影响的概率。实现起来也非常的简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$$emit: <span class="function"><span class="keyword">function</span> (<span class="params">eventName, data, privateName</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在私有事件池&#123;privateName&#125;中发布事件并执行回调</span></span><br><span class="line"><span class="comment">// 保证同一controller中的所有事件都先被注册，所以异步触发事件</span></span><br><span class="line">    tools.asyncFunc(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!privateName)&#123;</span><br><span class="line">            tools.emit(<span class="string">'publicPool'</span>, eventName, data);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tools.emit(privateName, eventName, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">$$on: <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback, privateName</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 在私有事件池&#123;privateName&#125;中注册事件</span></span><br><span class="line"><span class="keyword">if</span>(!privateName)&#123;</span><br><span class="line">        tools.on(<span class="string">'publicPool'</span>, eventName, callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        tools.on(privateName, eventName, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tools中的具体实现</span></span><br><span class="line">emit: <span class="function"><span class="keyword">function</span> (<span class="params">poolName, eventName, data</span>) </span>&#123;</span><br><span class="line">    eventPools[poolName] = eventPools[poolName] || &#123;&#125;;</span><br><span class="line">    eventPools[poolName][eventName] = eventPools[poolName][eventName] || [];</span><br><span class="line">    eventPools[poolName][eventName].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">existCallback</span>) </span>&#123;</span><br><span class="line">        existCallback(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">on: <span class="function"><span class="keyword">function</span> (<span class="params">poolName, eventName, callback</span>) </span>&#123;</span><br><span class="line">    eventPools[poolName] = eventPools[poolName] || &#123;&#125;;</span><br><span class="line">    eventPools[poolName][eventName] = eventPools[poolName][eventName] || [];</span><br><span class="line">    <span class="comment">// 根据回调函数判断是否已监听，不允许重复监听</span></span><br><span class="line">    <span class="keyword">var</span> notExist = eventPools[poolName][eventName].every(<span class="function"><span class="keyword">function</span> (<span class="params">exsitCallback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exsitCallback !==  callback</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(notExist)&#123;</span><br><span class="line">        eventPools[poolName][eventName].push(callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'iBus can not use a callback multiple under '</span>+ eventName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看上面的代码也可以看出来其实就是很简单的根据privateName这个参数进行了判断，如果存在就创建私有事件池或直接使用已有的该私有事件池。同时还有一个点就是$$emit内部发布事件时执行了异步操作，这点是考虑，比较极端自身监听自身的情况，如果是同步emit的话就会有问题。  除此之外当然还要向外部提供一个off方法去销毁自己订阅。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是我在做angularjs组件间通信解决方案时的一个的大致思路和一些自己的思考，中间也想过很多的优化和附加功能，但是很多被我自己否决了，因为这毕竟是一个基础的业务无关服务，就应该是简单高可用的，无需太多的其他功能，那些应该在业务层去处理。  </p><hr><p>顺便，iBus的源码已上传至<a href="https://github.com/Aeolos1994/blog/blob/master/code/ibus.js" target="_blank" rel="noopener">aeolos1994`github-ibus.js</a>，欢迎查看源码批评指正</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作中需要维护一个AngularJs工程，维护过程中许多场景都需要在page、directive之间以及他们自身之间进行通信，如果现在需要在非父子组件之间通信，你会怎么做呢？使用angular自带的broadcast与emit吗？但是他们的实现机制类似原型链查找，需要一层一层的向上或向下遍历，性能不佳，今天我来分享一个我的解决方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="AngularJs" scheme="https://aeolos1994.github.io/tags/AngularJs/"/>
    
  </entry>
  
  <entry>
    <title>Js异步模型-EventLoop</title>
    <link href="https://aeolos1994.github.io/2018/06/01/Js%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B-EventLoop/"/>
    <id>https://aeolos1994.github.io/2018/06/01/Js异步实现模型-EventLoop/</id>
    <published>2018-06-01T17:41:20.000Z</published>
    <updated>2018-06-16T11:00:28.863Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JS作为一门脚步语言，具有<strong>事件驱动</strong>、<strong>异步</strong>、<strong>单线程</strong>等特点，今天我们就浅析一下关于JS如何做到异步的以及相关周边问题；<br><a id="more"></a></p><h3 id="如何实现异步操作"><a href="#如何实现异步操作" class="headerlink" title="如何实现异步操作"></a>如何实现异步操作</h3><p>JS若要实现异步操作，大家最容易想到的可能会是setTimeout或者Ajax，今天我们就从实现最简单的setTimeout入手；</p><pre><code>setTimeout(function () {    //do something here},1000);...=&gt;setTimeout(function () {    //do something here},0);...</code></pre><p>上面这部分代码就是最简单的一个setTimeout运用了，它表示在一秒之后执行一些指令。如果我们将setTimeout的第二个参数，即1000修改为0，那么它会立即执行吗？答案是不会的，因为setTimeout是异步的（准确的说，设置定时器这个动作是同步的，但是timeout触发的事件是异步的，后边我们详细的论述它）。异步操作将会在所有同步操作完成后执行，所以如果整个任务中，设置定时器后的同步任务如果执行耗时超过一秒，将会延迟setTimeout的回调执行；<br>顺便一提，<strong>即使整个任务只有一个setTimeout且定时器时长设置为0，回调函数也无法像同步方法一样立马执行</strong>，至少会延迟<strong>4ms</strong>，这是由HTML5规范规定的。</p><blockquote><p>In modern browsers, setTimeout()/setInterval() calls are throttled to a minimum of once every 4ms when successive calls are triggered due to callback nesting (where the nesting level is at least a certain depth), or after certain number of successive intervals.</p></blockquote><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h3><p>那么这个过程中，到底发生了什么呢？ 要想知道发生了什么，有一个概念或者说机制必须要知道，那就是event-loop;</p><blockquote><p>  Each ‘thread’ gets its own event loop, so each<br>     web worker gets its own, so it can execute<br>     independently, whereas all windows on the same<br>     origin share an event loop as they can<br>     synchronously communicate. The event loop runs<br>     continually, executing any tasks queued. </p></blockquote><p>翻译一下：<strong>每个线程都有自己的event-loop(事件循环)，因为每个web worker由于都有自己的线程，所以都有自己event-loop，这样才能保证web worker可以相互独立的运行，<code>同源</code>的所有窗口共享一个event-loop，所以它们才可以同步的进行通信(比如postMessage)。event-loop不断循环并执行队列中的任务。</strong></p><blockquote><h4 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE:"></a>NOTE:</h4><p>这里所说的同源不是指同源策略的同源。指的是<code>window.open</code>、<code>iframe</code>、<code>window.frame</code>等方法打开的同源窗口，具体细节可参考<a href="http://hassansin.github.io/shared-event-loop-among-same-origin-windows" target="_blank" rel="noopener">Shared Event-loop for Same-Origin Windows</a></p></blockquote><blockquote><p>所以，为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用本节所述的event loop。</p></blockquote><p>是不是有点晦涩难懂，下面结合event-loop我用一段代码结合图文详细解释一下代码的执行过程来进行理解：</p><pre><code>function sthBeforeTimeout () {    console.log(&apos;before&apos;);}setTimeout(function () {    console.log(&apos;timeout&apos;);})function sthAfterTimeout () {    console.log(&apos;after&apos;)}sthBeforeTimeout();sthAfterTimeout();</code></pre><p><img src="http://images2015.cnblogs.com/blog/903320/201705/903320-20170516235510557-6476946.png" alt="Event Loop"></p><ol><li>所有声明式函数都在代码执行之前预处理，所以在真正的代码执行时，所以第一个被压入Stack(主线程)中的方法为setTimeout，它触发了一个定时器，定时器到时触发timeout事件，并将其push到event queue中；</li><li>执行方法 sthBeforeTimeout</li><li>执行方法 sthAfterTimeout</li><li>event-loop开始循环检查event queue，发现有待处理的事件则按照FIFO的原则将其处理，处理方式为检查事件是否有关联方法或回调，如有则push到Stack中并执行它；</li></ol><p>上述简化后的过程，就是event-loop实现异步的过程，关键点就在于，<strong>event-loop是在所有的同步代码执行完成后，才去检查event-queue</strong>；</p><h3 id="macroTask-amp-microTask"><a href="#macroTask-amp-microTask" class="headerlink" title="macroTask &amp; microTask"></a>macroTask &amp; microTask</h3><p>说到这里，仿佛我们已经大概明白js的异步实现原理，但是不妨看一下下面的代码，猜一下在<strong>Chrome</strong>控制台中打印的会是什么？</p><pre><code>console.log(&apos;start&apos;);setTimeout(function () {    console.log(&apos;timeout&apos;)})Promise.resolve().then(function(){    console.log(&apos;then1&apos;);}).then(function () {    console.log(&apos;then2&apos;);})console.log(&apos;end&apos;);</code></pre><p>按照我们的正常理解，同步代码会先执行毫无疑问，然后是异步的，event-loop按照FIFO原则，循环的拿出相对早的那个事件并执行对应回调，那么执行顺序将会是’timeout‘、’then1‘、’then2’；</p><p>但是你实践了就会发现，并不是这样的，打印顺序是</p><pre><code>startendthen1then2timeout</code></pre><p>为何会这样子呢，不是说好的FIFO么，这里就涉及更深入的原理和一个概念<strong>task(macroTask)宏任务</strong>与<strong>microTask微任务</strong>；首先明确，event-loop有两种任务(笔者认为其实准确说是事件)队列，一种是macroTask queue，队列里对应的任务就是marcoTask，另一种就是microTask queue也就对应microTask；</p><p>那么既然是两种queue，js又是单线程的，肯定要分出个高下，也就是到底谁先被读取、被执行。根据HTML规范:</p><blockquote><p>If the stack of script settings objects is now empty, perform a microtask checkpoint.<br>   — HTML: Cleaning up after a callback step 3</p></blockquote><p><img src="https://github.com/aooy/aooy.github.io/blob/master/blog/issues5/img/application1.jpg?raw=true" alt="Event Loop"></p><p>如上图所示也就是macroTask被执行完毕，将会去检查微任务队列，看是否有需要处理的事件。而且根据定义还能看出整个代码的执行被浏览器认为是一个macroTask。那么看到这里，就可以意识到Promise.then和setTImeout是属于不同的任务种类的了，在Chrome中，Promise.then是作为一个微任务存在的，在macroTask队列检查完成后没有待执行的任务，就去检查微任务队列，发现有Promise的完成事件存在，则去执行then方法对应的回调，然后再次检查微任务队列，直到任务队列被清空。整理并细化一下规范则event-loop执行顺序如下表：</p><pre><code>1.MacroTask: 在tasks队列中选择最老的一个task，如果没有可选的任务，则跳到下边的microtasks步骤。2.将上边选择的task设置为正在运行的task。3.运行被选择的task。4.将event loop的currently running task变为null。5.从task队列里移除前边运行的task。6.Microtasks: 执行microtasks任务检查点。    (1).将microtask checkpoint的flag设为true。    (2).Microtask queue handling: 如果event loop的microtask队列为空，直接跳到第八步（Done）。    (3).在microtask队列中选择最老的一个任务。    (4).将上一步选择的任务设为event loop的currently running task。    (5).运行选择的任务。    (6).将event loop的currently running task变为null。    (7).将前面运行的microtask从microtask队列中删除，然后返回到第二步（Microtask queue handling）。    (8).Done: 每一个environment settings object它们的 responsible event loop就是当前的event loop，会给environment settings object发一个 rejected promises 的通知。    (9).清理IndexedDB的事务。    (10).将microtask checkpoint的flag设为flase。.7.更新渲染（Update the rendering）...8.如果这是一个worker event loop，但是没有任务在task队列中，并且WorkerGlobalScope对象的closing标识为true，则销毁event loop，中止这些步骤，然后进行定义在Web workers章节的run a worker。9.返回到第一步。</code></pre><p><strong>所以，Chrome中then1、then2先于timeout被打印的关键点就在于，then为微任务，setTimeout为宏任务，在同步代码作为宏任务执行完毕之后，event-loop将会先去检查微任务队列并执行回调；</strong></p><p>在上面的关于打印的问题，我一直在强调在chrome中，是因为规范中并未明确定义Promise.then到底是macroTask还是microTask，所以各个浏览器的event-loop实现方式可能不一致，若浏览器实现是将then作为宏任务的话，那么就会是timeout先于then1、then2打印了；</p><h3 id="task-origin"><a href="#task-origin" class="headerlink" title="task origin"></a>task origin</h3><p>上面说了两种task queue，那么我们再深入一些，每种task queue到底内部是什么样子的呢；首先还是一坨规范甩在下面，虽然枯燥晦涩，但对于我们对于底层实现原理的理解还是很有好处的。</p><blockquote><p>An event loop has multiple task sources which guarantees execution order within that source (specs such as IndexedDB define their own), but the browser gets to pick which source to take a task from on each turn of the loop. This allows the browser to give preference to performance sensitive tasks such as user-input.</p></blockquote><p>如规范所描述的每个event-loop都有多个marcoTask queue，这是因为宏任务有多个任务源，每个任务源都有一个对应的marcoTask queue，每个任务源对应的queue都可以保证是FIFO的，在多个marcoTask queue中规范允许浏览器主动选择先执行哪个queue，并以此实现对于用户操作的优先响应。而每个event-loop都只有一个microTask queue，如下图总结。</p><p><img src="https://github.com/aooy/aooy.github.io/blob/master/blog/issues5/img/eventLoop.jpg?raw=true" alt="event-loop"></p><p>让我们最后探究一下，到底不同任务类型的任务源是怎么区分的</p><pre><code>macroTask Origin    1. setTimeout    2. setInterval    3. setImmediate    4. I/O    5. UI rendering</code></pre><p>对于 <strong>microTask Origin</strong> HTML规范中并没有明确说明，根据浏览器实现和参考一些资料我们普遍认为下列为微任务源</p><pre><code>microTask Origin    1.process.nextTick    2.promises    3.Object.observe    4.MutationObserver</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上叙述基本就是event-loop的原理，懂了event-loop的工作方式，就明白了runtime为现代浏览器的js是如何实现异步的了；以一种通俗易懂方法解释的话可以这么形容：</p><blockquote><p>如果主线程是一辆货运车，那么event-loop就是分拣工，而任务就是货物，微任务是奢侈品，宏任务是日常消费品；</p><p>每种日常消费品都有自己专有的流水线(宏任务中多个任务源对应多个task queue)运输,所以日常消费品有多个流水线，而所有的奢饰品不分种类全部由一个流水线运输。</p><p>分拣工的工作规则是先去清空日常消费品的多个流水线，根据产品的价格由高到低在离他最近的日消品中依次将货物扔到货运车上。</p><p>每次分拣工都只拿一个日消品扔车上（毕竟不值钱，看不上），没有就不拿，然后立马再去奢侈品流水线看有没有待处理的奢侈品，有的话就把所有的奢侈品依次都轻轻的放在货运车上，没有了的话就再跑去多条日消品流水线那边检查并根据之前说的规则把货物扔车里。</p><p>分拣工就这样一直来回检查来回跑…</p></blockquote><p>总结并简化一下event-loop的工作方式就是：</p><pre><code>-&gt; 执行整个script(作为宏任务) -&gt; 检查微任务队列并执行直到微任务队列为空-&gt; 根据macroTask queue优先级执行宏任务-&gt; 更新视图-&gt; 检查微任务队列并执行直到微任务队列为空-&gt; ...</code></pre><h4 id="参考资料与图片来源"><a href="#参考资料与图片来源" class="headerlink" title="参考资料与图片来源"></a>参考资料与图片来源</h4><ol><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Jake`s blog</a></li><li><a href="https://github.com/aooy/blog/issues/5" target="_blank" rel="noopener">aooy`s github</a></li><li><a href="http://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">朴灵批注：再看Event-loop-阮一峰</a></li><li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" target="_blank" rel="noopener">Standard ECMA-262</a></li><li><a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">HTML Standard</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">Concurrency model and Event Loop</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，JS作为一门脚步语言，具有&lt;strong&gt;事件驱动&lt;/strong&gt;、&lt;strong&gt;异步&lt;/strong&gt;、&lt;strong&gt;单线程&lt;/strong&gt;等特点，今天我们就浅析一下关于JS如何做到异步的以及相关周边问题；&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://aeolos1994.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于mpvue的实现方式以及与vue联系的探究</title>
    <link href="https://aeolos1994.github.io/2018/05/07/Mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E9%9B%86/"/>
    <id>https://aeolos1994.github.io/2018/05/07/Mpvue开发小程序踩坑集/</id>
    <published>2018-05-07T20:11:54.000Z</published>
    <updated>2018-11-01T18:00:31.878Z</updated>
    
    <content type="html"><![CDATA[<p>Mpvue开发小程序踩坑集，以及使用过程对于mpvue的研究和思考,本次博文源于我在公司内部的一次技术分享，源keynote我将会放在文章末尾。<br><a id="more"></a></p><p>##目录</p><h3 id="1-什么是小程序"><a href="#1-什么是小程序" class="headerlink" title="1.什么是小程序"></a>1.什么是小程序</h3><pre><code>1.1  小程序介绍1.2  小程序特点与限制1.3  原生小程序文件结构</code></pre><h3 id="2-Mpvue怎么来的"><a href="#2-Mpvue怎么来的" class="headerlink" title="2.Mpvue怎么来的"></a>2.Mpvue怎么来的</h3><pre><code>2.1  为什么要有Mpvue2.2  小程序原理2.3  Vue MVVM原理2.4  Mpvue切入点</code></pre><h3 id="3-Mpvue实现原理"><a href="#3-Mpvue实现原理" class="headerlink" title="3.Mpvue实现原理"></a>3.Mpvue实现原理</h3><pre><code>3.1  Compiler3.2  生命周期关联3.3  事件代理3.4  数据同步3.5  实例化过程概览</code></pre><h3 id="4-使用Mpvue开发"><a href="#4-使用Mpvue开发" class="headerlink" title="4.使用Mpvue开发"></a>4.使用Mpvue开发</h3><pre><code>4.1   准备工作4.2   如何调试4.3   如何配置</code></pre><h3 id="5-踩坑指南"><a href="#5-踩坑指南" class="headerlink" title="5.踩坑指南"></a>5.踩坑指南</h3><p><strong>下面进入正文</strong></p><h3 id="什么是小程序"><a href="#什么是小程序" class="headerlink" title="什么是小程序"></a>什么是小程序</h3><p>微信内部的轻量级应用，<br>一种全新的连接用户与服务的方式</p><h3 id="为什么是小程序"><a href="#为什么是小程序" class="headerlink" title="为什么是小程序"></a>为什么是小程序</h3><ol><li>基于微信 - 触达用户广泛</li><li>轻量级 - 即来即用，用完就走</li><li>病毒式传播 - 可以随手转发</li><li>开发简单 - 尤其对于前端</li><li>原生体验 - 可以借助很多微信提供的API</li></ol><h3 id="为什么要有Mpvue"><a href="#为什么要有Mpvue" class="headerlink" title="为什么要有Mpvue"></a>为什么要有Mpvue</h3><ol><li>实现了技术栈统一</li><li>组件化开发</li><li>多端代码复用</li><li>降低学习成本</li><li>提高开发效率的目标</li></ol><h3 id="小程序的特点与限制"><a href="#小程序的特点与限制" class="headerlink" title="小程序的特点与限制"></a>小程序的特点与限制</h3><ol><li>会下载整个小程序包</li><li>小程序大小限制2M</li><li>多页面应用</li></ol><h3 id="原生小程序文件构成"><a href="#原生小程序文件构成" class="headerlink" title="原生小程序文件构成"></a>原生小程序文件构成</h3><table><thead><tr><th>文件</th><th>作用 </th></tr></thead><tbody><tr><td>WXML</td><td>描述页面结构</td></tr><tr><td>WXSS</td><td>定义页面元素的样式</td></tr><tr><td>JS</td><td>业务逻辑、用户交互</td></tr><tr><td>JSON</td><td>主要用作配置文件</td></tr></tbody></table><h3 id="小程序对比Vue逻辑视图层交互"><a href="#小程序对比Vue逻辑视图层交互" class="headerlink" title="小程序对比Vue逻辑视图层交互"></a>小程序对比Vue逻辑视图层交互</h3><p>我们先看一下原生小程序是如何在逻辑与页面之间进行交互的<br><a href="https://postimg.cc/ykvSmvgC" target="_blank" rel="noopener"><img src="https://i.postimg.cc/VkcBchzv/image.png" alt="image.png"></a></p><p>在原生小程序内部有一个setData方法，有些类似react的shouldUpdateComponent，作用就是逻辑层通知视图层更新页面，而视图层的交互触发逻辑处理，依然是event。</p><p>虽然Vue我们都知道是通过defineProperty（Vue3.0版本将会使用Proxy）来进行双向绑定的，但是为了对比，我们还是再捋一下其中的流程与原理。</p><p><a href="https://postimg.cc/YL2CjBxG" target="_blank" rel="noopener"><img src="https://i.postimg.cc/7h0GsxGV/Vue.png" alt="Vue.png"></a></p><p>首先从renderFunction开始，生成虚拟dom树，在执行renderFunction中的过程中将会从vue实例中取值，如data, props, computed等等。这些数据都设置了getter, 在getter中Vue为数据对象设置了Dep对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mpvue开发小程序踩坑集，以及使用过程对于mpvue的研究和思考,本次博文源于我在公司内部的一次技术分享，源keynote我将会放在文章末尾。&lt;br&gt;
    
    </summary>
    
    
      <category term="miniprogram" scheme="https://aeolos1994.github.io/tags/miniprogram/"/>
    
  </entry>
  
  <entry>
    <title>关于一棵树的优化之路包括一些思考</title>
    <link href="https://aeolos1994.github.io/2018/03/22/optimization_of_tree/"/>
    <id>https://aeolos1994.github.io/2018/03/22/optimization_of_tree/</id>
    <published>2018-03-22T12:20:09.000Z</published>
    <updated>2018-11-01T18:15:42.755Z</updated>
    
    <content type="html"><![CDATA[<p>最近带的新人碰到了一个关于树节点渲染的需求，小伙伴写完之后发现对节点进行操作，比如选中时卡顿非常明显，跑来找我看看为什么。由此引发了我对优化这棵树的一系列的想法与实践，特别记录一下<br><a id="more"></a></p><h1 id="这棵树为什么会卡？"><a href="#这棵树为什么会卡？" class="headerlink" title="这棵树为什么会卡？"></a>这棵树为什么会卡？</h1><p>首先我们要明确的是卡在哪个步骤，是GUI渲染节点过多，导致js挂起实践太久导致的卡还是单纯js计算量大导致卡顿。经过查看后端返回数据和code review我发现，俩问题都有（笑哭）。</p><p>1、 后端返回数据量较大，这棵树结构大概有近3000的节点，一次性渲染确定会导致渲染慢<br>2、 需求中有一个特别简单易懂的需求，就是父节点选中时应该选中所有的广义子节点。小伙子非常耿直的进行了递归操作来操作子节点属性（当然这也是最容易想到的方案），导致js在这个宏任务中消耗了太久时间。</p><h1 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h1><p>首先我们分析需求并简化，将其从业务中抽象出来，以后说不定也用得着。</p><p>###需求：</p><pre><code>1. 选中父节点时，则选中所有子节点2. 选中所有子节点时，父节点也需要对应选中3. 所有节点支持前端搜索过滤</code></pre><p>###节点结构<br>简化节点结构，忽略所有优化无关的键值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">id,</span><br><span class="line">name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.postimg.cc/cJBcW3wM/TreeNode.png" alt="TreeNodes"></p><p>举个栗子，如果按递归的方法说这时候节点D被选中，那么F节点被选中，由于B只有F一个子节点，B将被选中，此时需要判断C节点是否处于选中状态，如果C选中，那么A也应该被选中。</p><h1 id="抽象、优化逻辑"><a href="#抽象、优化逻辑" class="headerlink" title="抽象、优化逻辑"></a>抽象、优化逻辑</h1><h3 id="数据结构上的优化"><a href="#数据结构上的优化" class="headerlink" title="数据结构上的优化"></a>数据结构上的优化</h3><p>首先节点关系广义上只有父子关系，但是由于递归遍历带来的时间与性能消耗过大，那么避免或减少递归是最直接有效的方案，又因为树的遍历递归是不可避免的，所以我们现在要考虑的有更简单数据结构供我们用来操作对应父子节点。<br>那么当时我考虑的有两个数据结构方案：</p><pre><code>1. 将父子关系从非线性结构打平为线性结构，父找子好找，但子不好回溯父节点2. 将树变为非连通的图，每个父节点都保存所有子节点的引用，同时子节点保存所有父节点的引用，但是存在对象互相引用</code></pre><p>基于两种解决方案以及搜索需求，我给出的最终解决方案是还是基于图结构做，但是非直接父子节点之间的联系并不做直接指向，而是保存id数组，并构建一个映射表，id一一映射到节点上。简单来说就是，每一个节点都有一个属性来记录所有子节点id（深度遍历序）和所有的父节点id（倒序），还需要导出一个映射表。这些操作我们在一次递归中就可以做到，依然是栗子🌰：</p><p><strong>里面的奇怪方法我们先不管它，后面会说</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options为指定id字段名称的配置项</span></span><br><span class="line"><span class="comment">// mapper为初始映射表 空对象</span></span><br><span class="line">treeData.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  recursion(treeData, options, mapper)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * [recursion description]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; data    [待递归的数据]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; options [数据参数]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; mapper  [数据打平结构的引用]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; parent  [递归时的父节点]</span></span><br><span class="line"><span class="comment">    * @return &#123;[type]&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">data, options, mapper, parent</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 构建映射表</span></span><br><span class="line">     mapper[data[options.fieldMap.id]] = data</span><br><span class="line">     <span class="comment">// 记录当前节点的所有父节点</span></span><br><span class="line">     <span class="keyword">if</span> (parent &amp;&amp; parent.parentsPath) &#123;</span><br><span class="line">       data.parentsPath = <span class="built_in">Array</span>.from(parent.parentsPath)</span><br><span class="line">       data.parentsPath.push(parent[options.fieldMap.id])</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       data.parentsPath = []</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 递归 并记录当前节点的所有子节点</span></span><br><span class="line">     data.childrenPath = []</span><br><span class="line">     <span class="keyword">if</span> (data[options.fieldMap.children] &amp;&amp; data[options.fieldMap.children].length) &#123;</span><br><span class="line">       data[options.fieldMap.children].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">         <span class="comment">// 设置默认的node show状态为true</span></span><br><span class="line">         <span class="keyword">if</span> (child[options.fieldMap.show] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">           child[options.fieldMap.show] = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         setWatcher(child, options.watchKeys, idGenerator(child[options.fieldMap.id]))</span><br><span class="line">         data.childrenPath = data.childrenPath.concat(recursion(child, options, mapper,</span><br><span class="line">           data))</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> childrenPathCopy = <span class="built_in">Array</span>.from(data.childrenPath)</span><br><span class="line">     childrenPathCopy.push(data[options.fieldMap.id])</span><br><span class="line">     <span class="keyword">return</span> childrenPathCopy</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实可以看出我们为了达到一遍递归做到整理数据的方式就是，每次的递归参数都包含了父节点的信息，而递归的返回值就是子节点的信息。</p><p>###不要递归<br>这就形成一个这样的数据结构：假设父子孙节点分别为A、B、C，那么A中childrenPath属性包含BC节点的id，而B的parentPath数组中包含A，C的parentPath按序包含[A, B]。这样形成的结构，在处理上述需求时就简单了很多。比如，在子被选中时，我要判断兄弟节点，那么我直接拿当前节点的parentPath.slice(-1)在字典中对应的节点即为当前节点的父节点，然后去拿所有父节点的直接子节点遍历判断，当然此时往上找时不需要递归，循环parentPath即可，return条件为某一级父节点不被选中。向下选也是如此，拿childrenPath即可。</p><p>#渲染</p><p>挖个坑后面补~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近带的新人碰到了一个关于树节点渲染的需求，小伙伴写完之后发现对节点进行操作，比如选中时卡顿非常明显，跑来找我看看为什么。由此引发了我对优化这棵树的一系列的想法与实践，特别记录一下&lt;br&gt;
    
    </summary>
    
    
      <category term="optmization" scheme="https://aeolos1994.github.io/tags/optmization/"/>
    
  </entry>
  
</feed>
