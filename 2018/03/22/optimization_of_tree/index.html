<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于一棵树的优化之路包括一些思考 · Aeolos</title><meta name="description" content="关于一棵树的优化之路包括一些思考 - Aeolos"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/fav.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://aeolos1994.github.io/atom.xml" title="Aeolos"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/aeolos1994" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于一棵树的优化之路包括一些思考</h1><div class="post-info">Mar 22, 2018</div><div class="post-content"><p>最近带的新人碰到了一个关于树节点渲染的需求，小伙伴写完之后发现对节点进行操作，比如选中时卡顿非常明显，跑来找我看看为什么。由此引发了我对优化这棵树的一系列的想法与实践，特别记录一下<br><a id="more"></a></p>
<h1 id="这棵树为什么会卡？"><a href="#这棵树为什么会卡？" class="headerlink" title="这棵树为什么会卡？"></a>这棵树为什么会卡？</h1><p>首先我们要明确的是卡在哪个步骤，是GUI渲染节点过多，导致js挂起实践太久导致的卡还是单纯js计算量大导致卡顿。经过查看后端返回数据和code review我发现，俩问题都有（笑哭）。</p>
<p>1、 后端返回数据量较大，这棵树结构大概有近3000的节点，一次性渲染确定会导致渲染慢<br>2、 需求中有一个特别简单易懂的需求，就是父节点选中时应该选中所有的广义子节点。小伙子非常耿直的进行了递归操作来操作子节点属性（当然这也是最容易想到的方案），导致js在这个宏任务中消耗了太久时间。</p>
<h1 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h1><p>首先我们分析需求并简化，将其从业务中抽象出来，以后说不定也用得着。</p>
<p>###需求：</p>
<pre><code>1. 选中父节点时，则选中所有子节点
2. 选中所有子节点时，父节点也需要对应选中
3. 所有节点支持前端搜索过滤
</code></pre><p>###节点结构<br>简化节点结构，忽略所有优化无关的键值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">	id,</span><br><span class="line">	name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.postimg.cc/cJBcW3wM/TreeNode.png" alt="TreeNodes"></p>
<p>举个栗子，如果按递归的方法说这时候节点D被选中，那么F节点被选中，由于B只有F一个子节点，B将被选中，此时需要判断C节点是否处于选中状态，如果C选中，那么A也应该被选中。</p>
<h1 id="抽象、优化逻辑"><a href="#抽象、优化逻辑" class="headerlink" title="抽象、优化逻辑"></a>抽象、优化逻辑</h1><h3 id="数据结构上的优化"><a href="#数据结构上的优化" class="headerlink" title="数据结构上的优化"></a>数据结构上的优化</h3><p>首先节点关系广义上只有父子关系，但是由于递归遍历带来的时间与性能消耗过大，那么避免或减少递归是最直接有效的方案，又因为树的遍历递归是不可避免的，所以我们现在要考虑的有更简单数据结构供我们用来操作对应父子节点。<br>那么当时我考虑的有两个数据结构方案：</p>
<pre><code>1. 将父子关系从非线性结构打平为线性结构，父找子好找，但子不好回溯父节点
2. 将树变为非连通的图，每个父节点都保存所有子节点的引用，同时子节点保存所有父节点的引用，但是存在对象互相引用
</code></pre><p>基于两种解决方案以及搜索需求，我给出的最终解决方案是还是基于图结构做，但是非直接父子节点之间的联系并不做直接指向，而是保存id数组，并构建一个映射表，id一一映射到节点上。简单来说就是，每一个节点都有一个属性来记录所有子节点id（深度遍历序）和所有的父节点id（倒序），还需要导出一个映射表。这些操作我们在一次递归中就可以做到，依然是栗子🌰：</p>
<p><strong>里面的奇怪方法我们先不管它，后面会说</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options为指定id字段名称的配置项</span></span><br><span class="line"><span class="comment">// mapper为初始映射表 空对象</span></span><br><span class="line">treeData.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  	recursion(treeData, options, mapper)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * [recursion description]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; data    [待递归的数据]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; options [数据参数]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; mapper  [数据打平结构的引用]</span></span><br><span class="line"><span class="comment">    * @param  &#123;[type]&#125; parent  [递归时的父节点]</span></span><br><span class="line"><span class="comment">    * @return &#123;[type]&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">data, options, mapper, parent</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 构建映射表</span></span><br><span class="line">     mapper[data[options.fieldMap.id]] = data</span><br><span class="line">     <span class="comment">// 记录当前节点的所有父节点</span></span><br><span class="line">     <span class="keyword">if</span> (parent &amp;&amp; parent.parentsPath) &#123;</span><br><span class="line">       data.parentsPath = <span class="built_in">Array</span>.from(parent.parentsPath)</span><br><span class="line">       data.parentsPath.push(parent[options.fieldMap.id])</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       data.parentsPath = []</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 递归 并记录当前节点的所有子节点</span></span><br><span class="line">     data.childrenPath = []</span><br><span class="line">     <span class="keyword">if</span> (data[options.fieldMap.children] &amp;&amp; data[options.fieldMap.children].length) &#123;</span><br><span class="line">       data[options.fieldMap.children].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">         <span class="comment">// 设置默认的node show状态为true</span></span><br><span class="line">         <span class="keyword">if</span> (child[options.fieldMap.show] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">           child[options.fieldMap.show] = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         setWatcher(child, options.watchKeys, idGenerator(child[options.fieldMap.id]))</span><br><span class="line">         data.childrenPath = data.childrenPath.concat(recursion(child, options, mapper,</span><br><span class="line">           data))</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> childrenPathCopy = <span class="built_in">Array</span>.from(data.childrenPath)</span><br><span class="line">     childrenPathCopy.push(data[options.fieldMap.id])</span><br><span class="line">     <span class="keyword">return</span> childrenPathCopy</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其实可以看出我们为了达到一遍递归做到整理数据的方式就是，每次的递归参数都包含了父节点的信息，而递归的返回值就是子节点的信息。</p>
<p>###不要递归<br>这就形成一个这样的数据结构：假设父子孙节点分别为A、B、C，那么A中childrenPath属性包含BC节点的id，而B的parentPath数组中包含A，C的parentPath按序包含[A, B]。这样形成的结构，在处理上述需求时就简单了很多。比如，在子被选中时，我要判断兄弟节点，那么我直接拿当前节点的parentPath.slice(-1)在字典中对应的节点即为当前节点的父节点，然后去拿所有父节点的直接子节点遍历判断，当然此时往上找时不需要递归，循环parentPath即可，return条件为某一级父节点不被选中。向下选也是如此，拿childrenPath即可。</p>
<p>#渲染</p>
<p>挖个坑后面补~</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/07/Mpvue开发小程序踩坑集/" class="prev">PREV</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://aeolos1994.github.io">Aeolos</a>, powered by <a href="https://github.com/aeolos1994" target="_blank">Kongpei</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>