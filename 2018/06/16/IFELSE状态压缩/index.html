<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 状态压缩 - 解决复杂的判断嵌套 · Aeolos</title><meta name="description" content="状态压缩 - 解决复杂的判断嵌套 - Aeolos"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/fav.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://aeolos1994.github.io/atom.xml" title="Aeolos"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/aeolos1994" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">状态压缩 - 解决复杂的判断嵌套</h1><div class="post-info">Jun 16, 2018</div><div class="post-content"><p>之前在工作中碰到了这么一个需求,转化一下需求的话就像是经典的递归地狱一样有非常深层次的if-else嵌套，让我一时感觉非常棘手,整体结构如果不优化的话，会变得如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (boolean1) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> (boolean2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (boolean3) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">      <span class="keyword">if</span> (boolean4) &#123;</span><br><span class="line">        <span class="keyword">if</span> (boolean5) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (boolean6) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">if</span> (boolean7) &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (boolean8) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际需求甚至嵌套比这还要深，不做优化处理的话，代码的可读性与可维护性都会令后面的维护者崩溃，甚至有可能过一段时间连自己都看不懂在写什么。<br>所以我就在考虑如何将这种if-else嵌套打平，让其变得更容易理解与维护。首先我们来抽象这个需求，其实抽象一下的话就是我们在不同的复合条件下需要做不同的操作。关键问题就在于这个复合条件是一层层判断的，如何打平复合条件就成为了我们解决这个优化方案的key point。复合条件的每层判断都是基于父层的判断的，假如我们基于if-else判断的0 1特性，枚举所有的可能的状态，将每个判断条件都转成2进制的0||1，然后压缩为一个二进制的字符串，然后转成数字就可以构成一个 数字范围 - 操作的映射体系。其实这就是状态压缩的思想。  </p>
<blockquote>
<p>状态压缩动态规划<br>    动态规划的状态有时候比较难，不容易表示出来，需要用一些编码技术，把状态压缩的用简单的方式表示出来。典型方式：当需要表示一个集合有哪些元素时，往往利用2进制用一个整数表示。  </p>
</blockquote>
<p>举个例子：针对上面那段代码我们如何进行压缩优化呢<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> statusMapper = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">statusMapper = &#123;</span><br><span class="line">	[n1, n2]: doSth,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> operation = &#123;</span><br><span class="line">	noop () &#123;&#125;,</span><br><span class="line">	doSth1 () &#123;&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionStatus</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> status = []</span><br><span class="line">	<span class="comment">// 依次进行状态判断并转为数字0、1push进数组中</span></span><br><span class="line">	<span class="comment">// 整个状态的判断顺序必须是有序的，这会对后续的map操作有影响</span></span><br><span class="line">	status.push(<span class="built_in">Number</span>(boolean)) ...</span><br><span class="line">	<span class="comment">// 转为10进制</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(status.join(<span class="string">''</span>), <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在已经写好的mapper中查找对应操作</span></span><br><span class="line"><span class="keyword">let</span> decimal = collectionStatus()</span><br><span class="line"><span class="keyword">let</span> doSth = noop</span><br><span class="line">statusMapper.forEach(<span class="function">(<span class="params">operation, range</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(range[<span class="number">0</span>] &gt; state &amp;&amp; state &lt; range[<span class="number">1</span>])&#123;</span><br><span class="line">		doSth = operation</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation[doSth]()</span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/21/源码实现对比（一） 双向绑定/" class="prev">PREV</a><a href="/2018/06/14/AngularJs跨组件通信方案/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://aeolos1994.github.io">Aeolos</a>, powered by <a href="https://github.com/aeolos1994" target="_blank">Kongpei</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>